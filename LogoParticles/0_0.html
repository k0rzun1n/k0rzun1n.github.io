<!DOCTYPE html>
<html lang="en">
<!-- fat lines -->
	<head>
		<title>three.js webgl - loaders - OBJ loader</title>
		<meta charset="utf-8">
			<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
				<style>
					body {
						font - family: Monospace;
					background-color: #000;
					color: #fff;
					margin: 0px;
					overflow: hidden;
				}
		
	#info {
						color: #fff;
					position: absolute;
					top: 10px;
					width: 100%;
					text-align: center;
					z-index: 100;
					display: block;
				}
		
				#info a,
	.button {
						color: #f00;
					font-weight: bold;
					text-decoration: underline;
					cursor: pointer
				}
</style>
</head>

				<body>
					<script src="../build/three.js"></script>
					<script src="js/loaders/OBJLoader.js"></script>
					<script src="js/controls/OrbitControls.js"></script>

					<script type="x-shader/x-vertex" id="vertexshader">
					uniform float size;
					uniform float time;
					//uniform vec3 mousePos;
					varying vec3 vColor;
					float rand (float s) {
						return fract(sin(s*4378.5453123));
					}					
					void main() {
						vColor = color;
						// vColor = vec3(1., 1., 0.);

						vec4 mvPosition = modelViewMatrix * vec4(
							position *vec3(1., 1., 0.5)
							// + normal*max(0., 0.3 * (1. - time / 5000.) ) //can be done outside and eased there
							+ (vec3(0.5) - vec3(rand(position.x),rand(position.y),rand(position.z)))
							*max(0., 0.3 * (1. - time / 5000.) ) //can be done outside and eased there
							// + vec3(0., 0., 0.01) * sin(position.x*40. + time * 0.0013)
							, 1.0 );
						gl_PointSize = size * ( 300.0 / -mvPosition.z );
						// gl_PointSize = 5.* ( 300.0 / -mvPosition.z );
		
						gl_Position = projectionMatrix * mvPosition;
				
					}
		</script>
					<script type="x-shader/x-fragment" id="fragmentshader">
						uniform sampler2D texture;
						varying vec3 vColor;
						void main() {
							gl_FragColor = vec4(vColor, 1.);
							gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
						}
		</script>
					<script>

						var container;
				
						var camera, scene, renderer;
				
						var mouseX = 0, mouseY = 0;
				
						var windowHalfX = window.innerWidth / 2;
						var windowHalfY = window.innerHeight / 2;
				
						let particlesShMat;
						let controls;
						init();
						let timeStart = performance.now();
						animate();
				
				
		function init() {

					container = document.createElement('div');
					document.body.appendChild(container);
		
					camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 50, 150);
					camera.position.z = 100;
					controls = new THREE.OrbitControls(camera);
		
					scene = new THREE.Scene();
				
					let uniforms = {
						// texture: { value: new THREE.TextureLoader().load("textures/sprites/spark1.png") },
						texture: {value: new THREE.TextureLoader().load('textures/sprites/disc.png') },
						size: {value: 2.0 },
						time: {value: 0.0 },
				};
		
			particlesShMat = new THREE.ShaderMaterial({
							uniforms: uniforms,
						vertexShader: document.getElementById('vertexshader').textContent,
						fragmentShader: document.getElementById('fragmentshader').textContent,
		
						blending: THREE.AdditiveBlending,
						depthTest: false,
						transparent: true,
						vertexColors: true
					});
		
		
					var ambientLight = new THREE.AmbientLight(0xcccccc, 0.4);
					scene.add(ambientLight);
		
					var pointLight = new THREE.PointLight(0xffffff, 0.8);
					camera.add(pointLight);
					scene.add(camera);
		
					// texture
		
					var manager = new THREE.LoadingManager();
			manager.onProgress = function (item, loaded, total) {

							console.log(item, loaded, total);

						};
			
			var onProgress = function (xhr) {
				if (xhr.lengthComputable) {
					var percentComplete = xhr.loaded / xhr.total * 100;
						console.log(Math.round(percentComplete, 2) + '% downloaded');
					}
				};
	
			var onError = function (xhr) {
						};
			
			
			var loader = new THREE.OBJLoader(manager);
			loader.load('lpstl_poissonds.obj', function (object) {
			// loader.load('_logo/pds_fl0.obj', function (object) {
			object.traverse(function (child) {

				if (child instanceof THREE.Mesh) {
					let chGeo = child.geometry;
					console.log(chGeo.attributes.position.array.length);
					let origPosArr = chGeo.attributes.position.array;
					let origNormArr = chGeo.attributes.normal.array;
					let newPos = [];
					let newNorm = [];
					let newSize = [];
					let newColor = []; //308 - 203 hsb
					let mn = 100,mx = -100; //-0 0.019
					for (let i = 0; i < origPosArr.length; i += 3) {
						const x = origPosArr[i + 0];
						const y = origPosArr[i + 1];
						const z = origPosArr[i + 2];
						const xn = origNormArr[i + 0];
						const yn = origNormArr[i + 1];
						const zn = origNormArr[i + 2];
						let vv = y; mn = Math.min(mn, vv); mx = Math.max(mx, vv);
						
						const hFrom = 308/360;
						const hTo = 203/360;
						
						let hCur = hFrom + (y - (-0.165))/(0.232 - (-0.165))*(hTo-hFrom) ;
						let col = hsvToRgb(
							hCur
							// 206/360
							, 1, 1);
						// console.log(hCur.toFixed(3));
						// if (z >= 0.013) {
							newPos.push(x, y, z);
							// newPos.push(x, z, y);
							newNorm.push(xn, yn, zn);
							newColor.push(...col);
						// }
					}
					console.log("mn=" + mn.toFixed(3) + " mx="+  mx.toFixed(3));
					var newGeo = new THREE.BufferGeometry();
					newGeo.addAttribute('position', new THREE.BufferAttribute(
						new Float32Array(newPos), 3));
					newGeo.addAttribute('normal', new THREE.BufferAttribute(
						new Float32Array(newNorm), 3));
					newGeo.addAttribute('color', new THREE.BufferAttribute(
						new Float32Array(newColor), 3));
					console.log(chGeo);
					console.log(newGeo);
					var particles = new THREE.Points(newGeo, particlesShMat);

					// var particles = new THREE.Points(chGeo, particlesShMat);
					let sc = 150;
					particles.scale.set(sc, sc, sc);
					scene.add(particles);
				}
			});


		}, onProgress, onError);

		//

		renderer = new THREE.WebGLRenderer();
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
		container.appendChild(renderer.domElement);

		document.addEventListener('mousemove', onDocumentMouseMove, false);

		//

		window.addEventListener('resize', onWindowResize, false);
			
					}
			
		function hsvToRgb(h, s, v) {
			var r, g, b;

			var i = Math.floor(h * 6);
			var f = h * 6 - i;
			var p = v * (1 - s);
			var q = v * (1 - f * s);
			var t = v * (1 - (1 - f) * s);

			switch (i % 6) {
				case 0: r = v, g = t, b = p; break;
				case 1: r = q, g = v, b = p; break;
				case 2: r = p, g = v, b = t; break;
				case 3: r = p, g = q, b = v; break;
				case 4: r = t, g = p, b = v; break;
				case 5: r = v, g = p, b = q; break;
			}

			// return [ r * 255, g * 255, b * 255 ];
			return [ r, g, b ];
		}
	
	function onWindowResize() {

							windowHalfX = window.innerWidth / 2;
						windowHalfY = window.innerHeight / 2;
			
						camera.aspect = window.innerWidth / window.innerHeight;
						camera.updateProjectionMatrix();
			
						renderer.setSize(window.innerWidth, window.innerHeight);
			
					}
			
		function onDocumentMouseMove(event) {

							mouseX = (event.clientX - windowHalfX) / 2;
						mouseY = (event.clientY - windowHalfY) / 2;
			
					}
			
		function animate() {

							requestAnimationFrame(animate);

						particlesShMat.uniforms.time.value = performance.now()-timeStart;
						controls.update();
			
						render();
			
					}
			
		function render() {

							// camera.position.x += ( mouseX - camera.position.x ) * .05;
							// camera.position.y += ( - mouseY - camera.position.y ) * .05;

							// camera.lookAt( scene.position );

							renderer.render(scene, camera);

						}
				
	</script>

				</body>

</html>